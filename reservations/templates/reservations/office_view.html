<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>사무실 — 교리실 예약</title>
  <style>
/* === Layout: make grid fill the viewport without page scroll === */
    html, body { height: 100%; margin: 0; }
    *, *::before, *::after { box-sizing: border-box; }
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      display: flex;
      flex-direction: column;
      overflow: hidden;        /* prevent extra page scrollbar */
      padding: 12px;           /* consistent outer padding */
    }
    .topbar{ flex: 0 0 auto; display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom: 10px; }
    .banner{ flex: 0 0 auto; }  /* banner takes only needed height */
    .grid-wrap{
      flex: 1 1 auto;
      min-height: 0;           /* critical: allow inner scrolling */
      border: 1px solid #ddd;
      overflow: auto;          /* scroll only inside the grid */
      max-height: none;        /* remove 70vh cap */
    }
    
.topbar { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom: 10px; }
    table { border-collapse: collapse; width: 100%; min-width: 1100px; user-select:none; }
    th, td { border:1px solid #e5e5e5; padding: 6px; font-size: 12px; }
    th { position: sticky; top: 0; background: #fafafa; z-index: 2; }
    td.room { position: sticky; left: 0; background: #fff; z-index: 1; min-width: 140px; }
    .cell { height: 34px; min-width: 60px; cursor: pointer; }
    .busy { background: #f3f3ff; }
    .blocked { background: #fff3f3; }
    .selected { outline: 2px solid #333; outline-offset: -2px; }
    .label { font-weight: 600; }
    .muted { color:#666; font-size: 12px; }
    .pill { display:inline-block; padding: 2px 6px; border-radius: 999px; background:#eee; font-size: 12px; }

    /* time-change banner */
    .banner {
      display:none;
      border: 1px solid #ddd;
      background: #fffbe6;
      padding: 10px 12px;
      border-radius: 10px;
      margin: 0 0 12px 0;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .banner strong { font-size: 13px; }
    .banner .muted { font-size: 12px; }
    .banner .actions { margin-left:auto; display:flex; gap:8px; }
    .banner button { padding: 6px 10px; border:1px solid #ccc; border-radius: 8px; background:#fff; cursor:pointer; }
    .banner button.danger { border-color:#b00; color:#b00; }

    /* resize cursor */
    .cell.resize-left { cursor: ew-resize; }
    .cell.resize-right { cursor: ew-resize; }

    dialog { width: min(560px, 96vw); border: 1px solid #ddd; border-radius: 10px; padding: 14px; }
    .row { display:flex; gap:10px; align-items:center; margin: 8px 0; }
    .row label { width: 120px; font-size: 12px; color:#444; }
    .row input, .row textarea, .row select { flex:1; padding: 8px; border:1px solid #ddd; border-radius: 8px; }
    .actions { display:flex; gap:8px; justify-content:flex-end; margin-top: 12px; flex-wrap:wrap; }
    button { padding: 8px 10px; border:1px solid #ccc; border-radius: 8px; background:#fff; cursor:pointer; }
    button.primary { border-color:#111; }
    button.danger { border-color:#b00; color:#b00; }
    button.secondary { border-color:#777; }
    .hint { font-size: 12px; color:#666; margin-top: 6px; }

    /* repeat day toggle buttons (single row, squared) */
    .repeat-dow-group{
      display:flex;
      flex-wrap:nowrap;           /* keep in one line */
      gap:6px;
      overflow-x:auto;            /* if viewport is narrow, allow horizontal scroll */
      -webkit-overflow-scrolling: touch;
      padding-bottom:2px;
    }
    .repeat-dow{ position:absolute; opacity:0; width:1px; height:1px; }
    .dow-toggle{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:32px;
      height:32px;
      padding:0;
      line-height:1;
      border:1px solid #cfcfcf;
      border-radius:4px;
      background:#fff;
      cursor:pointer;
      font-size:13px;
      font-weight:700;
      user-select:none;
      flex:0 0 32px;              /* prevent shrinking into wrap */
    }
    .repeat-dow:focus + .dow-toggle{ outline:2px solid #333; outline-offset:2px; }
    .repeat-dow:checked + .dow-toggle{ background:#1f7a3a; color:#fff; border-color:#1f7a3a; }


    /* visual hint when time-change mode enabled */
    body.time-change .cell{ cursor: crosshair; }

/* === Selected date badge + Today button === */
.date-badge{
  display:inline-flex;
  align-items:center;
  gap:10px;
  padding:8px 12px;
  border-radius:999px;
  border:2px solid #111;
  background:#fff;
  color:#111;
  font-weight:800;
  letter-spacing:.2px;
  box-shadow:0 1px 0 rgba(0,0,0,.08);
  white-space:nowrap;
}
.date-badge .k{ opacity:.75; font-weight:700; font-size:12px; }
.date-badge .v{ font-size:15px; }
.btn-today{
  padding:8px 10px;
  border:1px solid #111;
  border-radius:8px;
  background:#111;
  color:#fff;
  cursor:pointer;
  font-weight:700;
}
.btn-today:hover{ filter:brightness(1.05); }


/* === Create (reserve) action bar === */
.createbar{
  position: fixed;
  right: 14px;
  bottom: 14px;
  z-index: 50;
  display: flex;
  gap: 8px;
  align-items: center;
  padding: 10px 12px;
  border: 1px solid #ddd;
  background: rgba(255,255,255,.98);
  border-radius: 999px;
  box-shadow: 0 8px 28px rgba(0,0,0,.12);
}
.createbar .txt{
  font-size: 12px;
  color:#222;
  white-space: nowrap;
}
.createbar button{
  padding: 8px 10px;
  border: 1px solid #ccc;
  border-radius: 999px;
  background: #fff;
  cursor: pointer;
  font-weight: 700;
}
.createbar button.primary{
  border-color:#111;
  background:#111;
  color:#fff;
}
.createbar button.secondary{
  border-color:#777;
}

</style>
</head>
<body>
  <div class="topbar">
    <h2 style="margin:0;">사무실 — 교리실 예약</h2>
    <form method="get" action="/office/">
      <label class="muted">날짜</label>
      <input type="date" id="date" name="date" value="{{ selected_date }}" />
      <button type="button" class="btn-today" id="btn-today">오늘</button>
      <span id="selected-date-badge" class="date-badge" aria-live="polite"></span>
      <button type="submit">보기</button>
    </form>
    <span class="pill" id="range-pill"></span>
    <span class="muted"> 빈칸 클릭 → 예약 생성 / 예약 블록 클릭 → 수정/취소 · (수정) 시간변경/리사이즈 가능</span>
  </div>

  <!-- Time change banner -->
  <div class="banner" id="time-banner">
    <div>
      <strong>시간 변경 모드</strong>
      <div class="muted">그리드에서 <b>시작 셀</b>을 먼저 클릭한 후 <b>종료 셀</b>을 클릭하세요. (같은 교리실에서만 가능)</div>
      <div class="muted">취소: ESC 또는 “취소” 버튼</div>
    </div>
    <div class="actions">
      <button type="button" class="danger" onclick="cancelTimeChangeMode()">취소</button>
    </div>
  </div>

  <div class="grid-wrap">
    <table id="grid">
      <thead></thead>
      <tbody></tbody>
    </table>
  </div>


  <!-- Create reservation bar (appears after selecting a time range) -->
  <div id="create-bar" class="createbar" hidden>
    <span class="txt" id="create-bar-text">선택됨</span>
    <button type="button" class="secondary" id="btn-create-cancel">취소</button>
    <button type="button" class="primary" id="btn-create-open">예약</button>
  </div>

  <dialog id="modal">
    <h3 id="modal-title" style="margin:0 0 8px 0;">예약</h3>

    <input type="hidden" id="res-id" />

    <div class="row">
      <label>교리실</label>
      <select id="room-id"></select>
    </div>
    <div id="time-fields">


    
    <div class="row">
      <label>날짜</label>
      <input id="modal-date" type="date" />
    </div>

<div class="row">
      <label>시작</label>
      <!-- click/focus opens native time picker -->
      <input id="start-at" type="time" step="1800" list="time-30-start">
    </div>

    <div class="row">
      <label>종료</label>
      <input id="end-at" type="time" step="1800" list="time-30-end">
    </div>

    <div class="row">
      <label>시간</label>
      <select id="duration">
        <option value="30">30분</option>
        <option value="60" selected>1시간</option>
        <option value="90">1시간 30분</option>
        <option value="120">2시간</option>
        <option value="150">2시간 30분</option>
        <option value="180">3시간</option>
        <option value="210">3시간 30분</option>
        <option value="240">4시간</option>
      </select>
      <div class="hint" id="end-preview" style="margin-left:92px;margin-top:6px;color:#666;"></div>
    </div>

    </div>

    
<div class="row" id="repeat-row">
  <label>반복 예약</label>
  <div style="display:flex;flex-direction:column;gap:10px;">
    <label style="display:flex;align-items:center;gap:10px;font-weight:700;white-space:nowrap;">
      <input id="repeat-enabled" type="checkbox" />
      반복 예약 사용
      <span style="font-size:12px;color:#888;font-weight:600;">(선택 시 요일/종료일 설정)</span>
    </label>

    <div id="repeat-options" style="display:none;flex-direction:column;gap:8px;">
      <div class="repeat-dow-group" aria-label="반복 요일 선택">
        <input id="dow-0" type="checkbox" class="repeat-dow" value="0"><label class="dow-toggle" for="dow-0">일</label>
        <input id="dow-1" type="checkbox" class="repeat-dow" value="1"><label class="dow-toggle" for="dow-1">월</label>
        <input id="dow-2" type="checkbox" class="repeat-dow" value="2"><label class="dow-toggle" for="dow-2">화</label>
        <input id="dow-3" type="checkbox" class="repeat-dow" value="3"><label class="dow-toggle" for="dow-3">수</label>
        <input id="dow-4" type="checkbox" class="repeat-dow" value="4"><label class="dow-toggle" for="dow-4">목</label>
        <input id="dow-5" type="checkbox" class="repeat-dow" value="5"><label class="dow-toggle" for="dow-5">금</label>
        <input id="dow-6" type="checkbox" class="repeat-dow" value="6"><label class="dow-toggle" for="dow-6">토</label>
      </div>

      <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;">
        <span style="font-size:13px;color:#666;">언제까지</span>
        <input id="repeat-until" type="date" />
        <span style="font-size:12px;color:#888;">요일을 1개 이상 선택하면 매주 반복됩니다.</span>
      </div>
    </div>
  </div>
</div>

<div class="row" id="cancel-scope-row" style="display:none;">
      <label>수정/취소 범위</label>
      <div style="display:flex;gap:14px;flex-wrap:wrap;">
        <label style="display:flex;align-items:center;gap:6px;font-weight:600;">
          <input type="radio" name="cancel-scope" value="single" checked>현재 예약만
        </label>
        <label style="display:flex;align-items:center;gap:6px;font-weight:600;">
          <input type="radio" name="cancel-scope" value="series">전체(반복 예약)
        </label>
      </div>
    </div>
    <div class="row">
      <label>단체명(공개)</label>
      <input id="title" type="text" placeholder="예: 유스그룹" />
    </div>

    <div class="row">
      <label>내부 메모</label>
      <textarea id="note" rows="3" placeholder="예: 담당자/연락처 등 (공개되지 않음)"></textarea>
    </div>

    <div class="row" id="pin-row">
      <label>수정/취소 PIN(4자리)</label>
      <input id="pin" type="password" inputmode="numeric" maxlength="4" placeholder="1234" />
    </div>

    <div class="row" id="new-pin-row" style="display:none;">
      <label>새 PIN(선택)</label>
      <input id="new-pin" type="password" inputmode="numeric" maxlength="4" placeholder="변경할 때만 입력" />
    </div>

    <div class="hint" id="modal-hint"></div>

    <div class="actions">
      <button type="button" onclick="closeModal()">닫기</button>
      <button type="button" id="btn-cancel" class="danger" style="display:none;" onclick="cancelReservation()">취소(비번 필요)</button>
      <button type="button" id="btn-save" class="primary" onclick="saveReservation()">저장(비번 필요)</button>
    </div>
      <datalist id="time-30-start"></datalist>
<datalist id="time-30-end"></datalist>
  </dialog>

  <script>
    // selected date helper (works for Django-rendered template AND static file)
    function getSelectedDate(){
      const el = document.getElementById("date") || document.querySelector('input[type="date"][name="date"]');
      const v = el ? String(el.value || "").trim() : "";
      if (/^\d{4}-\d{2}-\d{2}$/.test(v)) return v;
      const now = new Date();
      const y = now.getFullYear();
      const m = String(now.getMonth()+1).padStart(2,"0");
      const d = String(now.getDate()).padStart(2,"0");
      return `${y}-${m}-${d}`;
    }

    function ensureDateInputDefault(){
      const el = document.getElementById("date") || document.querySelector('input[type="date"][name="date"]');
      if (!el) return;
      const v = String(el.value || "").trim();
      if (!/^\d{4}-\d{2}-\d{2}$/.test(v)) el.value = getSelectedDate();
    }
const modal = document.getElementById("modal");
    const banner = document.getElementById("time-banner");

    let state = {
      data: null,
      dragging: false,
      dragRoomId: null,
      dragStartSlot: null,
      dragEndSlot: null,
      slotIndex: {},
      resById: {},
      cellMap: new Map(),

      // time change mode
      timeChangeMode: false,
      timeChangeForResId: null,
      timeChangeLockedRoomId: null,
      timeChangeStartSlot: null,

      // resize
      resRanges: {},     // resId -> { roomId, si, ei }
      resizeMode: null,  // { resId, roomId, edge: 'start'|'end' }

      // create selection (open modal via Reserve button)
      pendingCreate: null, // {roomId, startLabel, endLabel}
    };


// Global mouseup: ensure drag flags reset even if mouse is released outside cells
document.addEventListener("mouseup", () => { state.dragging = false; state.resizeMode = null; });

    function parseISO(s){ return new Date(s); }
    function hhmm(d){ return String(d.getHours()).padStart(2,"0")+":"+String(d.getMinutes()).padStart(2,"0"); }

    function closeModal(){ modal.close(); }
    function clearSelection(){ document.querySelectorAll(".selected").forEach(el => el.classList.remove("selected")); }

    function markSelection(roomId, startIdx, endIdx){
      clearSelection();
      const slots = state.data.slots;
      for (let i = startIdx; i < endIdx; i++){
        const key = roomId + "|" + slots[i];
        const td = state.cellMap.get(key);
        if (td) td.classList.add("selected");
      }
    }

    function hideCreateBar(){
      const bar = document.getElementById('create-bar');
      if (bar) bar.hidden = true;
      state.pendingCreate = null;
      const t = document.getElementById('create-bar-text');
      if (t) t.textContent = '';
    }

    function showCreateBar(roomId, startLabel, endLabel){
      try {
        state.pendingCreate = { roomId, startLabel, endLabel };
        const bar = document.getElementById('create-bar');
        const t = document.getElementById('create-bar-text');
        if (t) t.textContent = `선택: ${startLabel}–${endLabel}`;
        if (bar) {
          bar.hidden = false;
          console.log("[showCreateBar] visible with:", startLabel, endLabel);
        } else {
          console.error("[showCreateBar] create-bar element not found");
        }
      } catch(err) {
        console.error("[showCreateBar] error:", err);
      }
    }

    function openCreateFromBar(){
      try {
        const p = state.pendingCreate;
        if (!p){
          // Fallback: derive from current drag selection (in case pendingCreate was cleared)
          try{
            const roomId = state.dragRoomId;
            const sSlot = state.dragStartSlot;
            const eSlot = state.dragEndSlot;
            if (roomId && sSlot && eSlot && state.slotIndex && state.data && Array.isArray(state.data.slots)){
              const si = state.slotIndex[sSlot];
              const ei = state.slotIndex[eSlot];
              if (typeof si === "number" && typeof ei === "number"){
                const a = Math.min(si, ei);
                const b = Math.max(si, ei) + 1;
                const startLabel = state.data.slots[a];
                const endLabel = (b < state.data.slots.length) ? state.data.slots[b] : state.data.close;
                hideCreateBar();
                openCreate(roomId, startLabel, endLabel);
                return;
              }
            }
          } catch(e){ console.error("openCreateFromBar fallback error:", e); }
          console.error("openCreateFromBar: no pendingCreate and no fallback available");
          return;
        }
        hideCreateBar();
        console.log("[openCreateFromBar] opening:", p);
        openCreate(p.roomId, p.startLabel, p.endLabel);
      } catch(err) {
        console.error("[openCreateFromBar] unexpected error:", err);
        alert("예약 모달 오픈 중 오류가 발생했습니다: " + err.message);
      }
    }

    function cancelCreateSelection(){
      hideCreateBar();
      clearSelection();
    }

    function setModalModeCreate(){
      const tcRow = document.getElementById("time-change-row");
      if (tcRow) tcRow.style.display = "none";
      document.getElementById("time-fields").style.display = "";
      document.getElementById("repeat-row").style.display = "";
      document.getElementById("cancel-scope-row").style.display = "none";
      document.getElementById("new-pin-row").style.display = "none";
      document.getElementById("btn-cancel").style.display = "none";
      document.getElementById("btn-save").textContent = "생성";
      document.getElementById("modal-title").textContent = "예약 생성";
      document.getElementById("modal-hint").textContent = "수정/취소 PIN(4자리)은 생성 시 필수입니다.";
    }

    function setModalModeEdit(){
      document.getElementById("time-fields").style.display = "";
      document.getElementById("repeat-row").style.display = "none";
      document.getElementById("cancel-scope-row").style.display = "";
      document.getElementById("pin-row").style.display = "";
      document.getElementById("new-pin-row").style.display = "";
      document.getElementById("btn-cancel").style.display = "";
      document.getElementById("btn-save").textContent = "수정 저장";
      document.getElementById("modal-title").textContent = "예약 수정/취소";
      document.getElementById("modal-hint").textContent =
        "수정/취소 PIN(4자리)은 필수입니다.";
    }

    function openCreate(roomId, startLabel, endLabel){
      try {
        document.getElementById("res-id").value = "";
        document.getElementById("room-id").value = roomId;

        // date for reservation (defaults to selected date)
        const md = document.getElementById("modal-date");
        if (md) md.value = getSelectedDate();

        // start-at: HH:MM
        const startEl = document.getElementById("start-at");
        if (startEl) startEl.value = startLabel;

        // duration from selection (minutes)
        const dur = minutesBetweenHHMM_(startLabel, endLabel);
        setDuration_(dur);

        // end-at based on duration
        const endEl = document.getElementById("end-at");
        if (endEl){
          const endHH = addMinutesToHHMM_(startLabel, dur);
          endEl.value = endHH;
        }

        document.getElementById("title").value = "";
        document.getElementById("note").value = "";
        document.getElementById("pin").value = "";
        document.getElementById("new-pin").value = "";

        // repeat defaults
        const repEn = document.getElementById("repeat-enabled");
        const repOpts = document.getElementById("repeat-options");
        if (repEn) repEn.checked = false;
        if (repOpts) repOpts.style.display = "none";
        document.querySelectorAll(".repeat-dow").forEach(cb => cb.checked = false);
        const untilEl = document.getElementById("repeat-until");
        if (untilEl) untilEl.value = "";

        setModalModeCreate();
        updateEndPreview_();
        rebuildEndPickerFromStart_();
        console.log("[openCreate] modal.showModal() called");
        modal.showModal();
      } catch(err) {
        console.error("[openCreate] error:", err);
        alert("모달 열기 중 오류: " + err.message);
      }
    }

    function openEdit(resId){
      const r = state.resById[resId];
      if (!r) return;

      state.currentEdit = r;

      document.getElementById("res-id").value = r.id;
      document.getElementById("room-id").value = r.room_id;

      const s = parseISO(r.start_at);
      const e = parseISO(r.end_at);

      const sHH = hhmm(s);
      const eHH = hhmm(e);

      document.getElementById("start-at").value = sHH;

      // set duration based on existing reservation length
      const dur = minutesBetweenHHMM_(sHH, eHH);
      setDuration_(dur);

      // date for reservation
      const md = document.getElementById("modal-date");
      if (md){
        const ds = getSelectedDate();
        md.value = ds;
      }
      const endEl = document.getElementById("end-at");
      if (endEl) endEl.value = eHH;

      document.getElementById("title").value = r.title || "";
      document.getElementById("note").value = r.note_internal || "";
      document.getElementById("pin").value = "";
      document.getElementById("new-pin").value = "";

      // cancel scope UI
      const scopeRow = document.getElementById("cancel-scope-row");
      if (scopeRow) scopeRow.style.display = "";
      // if server provides series/group id, enable series option; otherwise still show but warn via hint
      const seriesRadio = scopeRow ? scopeRow.querySelector('input[value="series"]') : null;
      if (seriesRadio) seriesRadio.disabled = !(r.series_id || r.group_id || r.repeat_id);
      const singleRadio = scopeRow ? scopeRow.querySelector('input[value="single"]') : null;
      if (singleRadio) singleRadio.checked = true;

      setModalModeEdit();
      updateEndPreview_();
      rebuildEndPickerFromStart_();
      modal.showModal();
    }

    function setTimeChangeUI(on){
      banner.style.display = on ? "flex" : "none";
      document.body.classList.toggle("time-change", on);
    }

    function enableTimeChange(){
      const resId = document.getElementById("res-id").value;
      if (!resId){
        alert("예약 수정 모드에서만 시간 변경이 가능합니다.");
        return;
      }
      const lockedRoomId = document.getElementById("room-id").value;
      state.timeChangeMode = true;
      state.timeChangeForResId = resId;
      state.timeChangeLockedRoomId = lockedRoomId;

      setTimeChangeUI(true);
      // 모달을 닫지 않고 그리드 상호작용 가능하게 유지
    }

    function cancelTimeChangeMode(){
      state.timeChangeMode = false;
      state.timeChangeForResId = null;
      state.timeChangeLockedRoomId = null;
      state.timeChangeStartSlot = null;
      setTimeChangeUI(false);
      clearSelection();
    }

    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && state.timeChangeMode){
        e.preventDefault();
        cancelTimeChangeMode();
      }
    });

    function applyResizeToModal(resId, roomId, startLabel, endLabel){
      const r = state.resById[resId];
      if (!r) return;

      document.getElementById("res-id").value = resId;
      document.getElementById("room-id").value = roomId;
      document.getElementById("start-at").value = startLabel;
      const endEl = document.getElementById("end-at");
      if (endEl) endEl.value = endLabel;
      const dur = minutesBetweenHHMM_(startLabel, endLabel);
      setDuration_(dur);
      updateEndPreview_();

      document.getElementById("title").value = r.title || "";
      document.getElementById("note").value  = r.note_internal || "";
      document.getElementById("pin").value = "";
      document.getElementById("new-pin").value = "";

      setModalModeEdit();
      modal.showModal();
    }

    function buildRoomSelect(){
      const sel = document.getElementById("room-id");
      sel.innerHTML = "";
      state.data.rooms.forEach(r => {
        const opt = document.createElement("option");
        opt.value = r.id;
        opt.textContent = r.name;
        sel.appendChild(opt);
      });
    }

    async function load(){
      hideCreateBar();
      clearSelection();
      const res = await fetch(`/api/office/grid?date=${encodeURIComponent(getSelectedDate())}`);
      if (!res.ok) {
        const t = await res.text();
        throw new Error(`Grid API failed: HTTP ${res.status} ${t.slice(0,200)}`);
      }
      state.data = await res.json();

      document.getElementById("range-pill").textContent =
        `${state.data.date}  ${state.data.open}–${state.data.close}  (30분 단위)`;

      buildRoomSelect();

      state.slotIndex = {};
      state.data.slots.forEach((t, idx) => state.slotIndex[t] = idx);

      state.resById = {};
      state.data.reservations.forEach(r => state.resById[r.id] = r);

      renderGrid();
    
      rebuildTimePickersFromGrid_();
      rebuildEndPickerFromStart_();
}

    function rebuildTimePickersFromGrid_(){
  // Build 30-min time suggestions limited to the current grid open~close range.
  // start: slots[]; end: slots[] plus close (so end can be exactly closing time)
  const dlStart = document.getElementById("time-30-start");
  const dlEnd = document.getElementById("time-30-end");
  if (!dlStart || !dlEnd) return;
  if (!state || !state.data || !Array.isArray(state.data.slots)) return;

  const slots = state.data.slots.slice(); // e.g., ["09:00","09:30",...]
  const close = state.data.close;

  // Clear
  dlStart.innerHTML = "";
  dlEnd.innerHTML = "";

  // Populate start options (open..last slot)
  for (const t of slots){
    const opt = document.createElement("option");
    opt.value = t;
    dlStart.appendChild(opt);
  }

  // Populate end options (slots + close)
  for (const t of slots){
    const opt = document.createElement("option");
    opt.value = t;
    dlEnd.appendChild(opt);
  }
  if (close && !slots.includes(close)){
    const opt = document.createElement("option");
    opt.value = close;
    dlEnd.appendChild(opt);
  }
}

function minutesFromHHMM_(hhmmStr){
  const a = parseHHMM_(hhmmStr);
  if (!a) return null;
  return a.h*60 + a.m;
}

function rebuildEndPickerFromStart_(){
  // Narrow end-time suggestions to only times AFTER the selected start, within open~close.
  const dlEnd = document.getElementById("time-30-end");
  const startEl = document.getElementById("start-at");
  if (!dlEnd || !startEl) return;
  if (!state || !state.data || !Array.isArray(state.data.slots)) return;

  const startHH = String(startEl.value || "").trim();
  const sMin = minutesFromHHMM_(startHH);
  const slots = state.data.slots.slice();
  const close = state.data.close;

  dlEnd.innerHTML = "";

  // If start is invalid/empty, fall back to full range (slots + close)
  if (sMin === null){
    for (const t of slots){
      const opt = document.createElement("option");
      opt.value = t;
      dlEnd.appendChild(opt);
    }
    if (close && !slots.includes(close)){
      const opt = document.createElement("option");
      opt.value = close;
      dlEnd.appendChild(opt);
    }
    return;
  }

  // Only times at least 30 minutes after start
  for (const t of slots){
    const m = minutesFromHHMM_(t);
    if (m !== null && m >= sMin + 30){
      const opt = document.createElement("option");
      opt.value = t;
      dlEnd.appendChild(opt);
    }
  }
  // Allow choosing exactly "close" as an end time if it's after start
  const cMin = minutesFromHHMM_(close);
  if (close && cMin !== null && cMin > sMin && !slots.includes(close)){
    const opt = document.createElement("option");
    opt.value = close;
    dlEnd.appendChild(opt);
  }

  // If current end is not after start, auto-adjust end based on duration (or minimum 30m)
  const endEl = document.getElementById("end-at");
  const durEl = document.getElementById("duration");
  if (!endEl) return;

  const curEnd = String(endEl.value || "").trim();
  const eMin = minutesFromHHMM_(curEnd);

  // derive preferred end
  let preferredEnd = "";
  if (durEl && durEl.value){
    preferredEnd = addMinutesToHHMM_(startHH, Number(durEl.value||30));
  } else {
    preferredEnd = addMinutesToHHMM_(startHH, 30);
  }

  const pMin = minutesFromHHMM_(preferredEnd);
  const closeMin = cMin;

  // clamp preferredEnd to close if needed
  if (closeMin !== null && pMin !== null && pMin > closeMin){
    preferredEnd = close;
  }

  // only update if end is invalid/empty or too early (not after start)
  // but preserve a valid end time that's at least 30 min after start
  if (eMin === null || (eMin !== null && eMin < sMin + 30)){
    endEl.value = preferredEnd;
  }
}

function renderGrid(){
      const thead = document.querySelector("#grid thead");
      const tbody = document.querySelector("#grid tbody");
      thead.innerHTML = "";
      tbody.innerHTML = "";
      state.cellMap = new Map();
      state.resRanges = {};

      const trh = document.createElement("tr");
      const th0 = document.createElement("th");
      th0.textContent = "교리실";
      trh.appendChild(th0);

      state.data.slots.forEach(t => {
        const th = document.createElement("th");
        th.textContent = t;
        trh.appendChild(th);
      });
      thead.appendChild(trh);

      const byRoom = {};
      state.data.rooms.forEach(r => byRoom[r.id] = {res:[], blocks:[]});
      state.data.reservations.forEach(r => { if (byRoom[r.room_id]) byRoom[r.room_id].res.push(r); });

      state.data.blocks.forEach(b => {
        if (b.room_id === null) state.data.rooms.forEach(r => byRoom[r.id].blocks.push(b));
        else if (byRoom[b.room_id]) byRoom[b.room_id].blocks.push(b);
      });

      function markRange(cells, item, cls, text, resId){
        const s = parseISO(item.start_at);
        const e = parseISO(item.end_at);
        const ss = hhmm(s);
        const ee = hhmm(e);

        const si = state.slotIndex[ss];
        const ei = state.slotIndex[ee];
        if (si === undefined) return;

        const endIdx = (ei === undefined) ? state.data.slots.length : ei;

        if (resId) {
          state.resRanges[resId] = { roomId: item.room_id, si, ei: endIdx };
        }

        for (let i=si; i<endIdx; i++){
          cells[i].classList.add(cls);
          if (resId) {
            cells[i].dataset.resId = resId;
            if (i === si) cells[i].dataset.edgeStart = "1";
            if (i === endIdx - 1) cells[i].dataset.edgeEnd = "1";
          }
          if (i === si && text) cells[i].textContent = text;
        }
      }

      state.data.rooms.forEach(room => {
        const tr = document.createElement("tr");

        const tdRoom = document.createElement("td");
        tdRoom.className = "room";
        tdRoom.innerHTML = `<span class="label">${room.name}</span>`;
        tr.appendChild(tdRoom);

        const cells = [];
        for (let i=0; i<state.data.slots.length; i++){
          const td = document.createElement("td");
          td.className = "cell";
          td.dataset.roomId = room.id;
          td.dataset.slot = state.data.slots[i];

          td.addEventListener("mousemove", (e) => {
            if (state.timeChangeMode) {
              td.classList.remove("resize-left", "resize-right");
              return;
            }
            if (!td.dataset.resId) {
              td.classList.remove("resize-left", "resize-right");
              return;
            }
            const w = td.getBoundingClientRect().width;
            const x = e.offsetX;

            const isStartEdgeCell = td.dataset.edgeStart === "1";
            const isEndEdgeCell   = td.dataset.edgeEnd === "1";

            td.classList.remove("resize-left", "resize-right");
            if (isStartEdgeCell && x <= 10) td.classList.add("resize-left");
            else if (isEndEdgeCell && x >= w - 10) td.classList.add("resize-right");
          });

          td.addEventListener("mousedown", () => {
            // ✅ resize start
            if (!state.timeChangeMode && td.dataset.resId) {
              const resId = td.dataset.resId;
              if (td.classList.contains("resize-left") || td.classList.contains("resize-right")) {
                const edge = td.classList.contains("resize-left") ? "start" : "end";
                const rr = state.resRanges[resId];
                if (!rr) return;
                if (String(rr.roomId) !== String(room.id)) return;

                state.resizeMode = { resId, roomId: room.id, edge };
                state.dragging = true;
                state.dragRoomId = room.id;
                state.dragStartSlot = td.dataset.slot;
                state.dragEndSlot = td.dataset.slot;

                const si = state.slotIndex[state.dragStartSlot];
                markSelection(room.id, si, si+1);
                return;
              }
            }

            // ✅ time change mode: 클릭으로 시작/종료 셀 순차 선택
            if (state.timeChangeMode){
              hideCreateBar();
              if (state.timeChangeLockedRoomId && String(room.id) !== String(state.timeChangeLockedRoomId)){
                return;
              }
              
              // 첫 번째 클릭: 시작 셀 선택
              if (!state.timeChangeStartSlot){
                state.timeChangeStartSlot = td.dataset.slot;
                const si = state.slotIndex[state.timeChangeStartSlot];
                markSelection(room.id, si, si+1);
                return;
              }
              
              // 두 번째 클릭: 종료 셀 선택 및 처리
              const endSlot = td.dataset.slot;
              const si = state.slotIndex[state.timeChangeStartSlot];
              const ei = state.slotIndex[endSlot];
              const a = Math.min(si, ei);
              const b = Math.max(si, ei) + 1;
              
              const startLabel = state.data.slots[a];
              const endLabel = (b < state.data.slots.length) ? state.data.slots[b] : state.data.close;
              
              // 모달 필드 업데이트
              state.timeChangeMode = false;
              state.timeChangeStartSlot = null;
              state.timeChangeLockedRoomId = null;
              setTimeChangeUI(false);
              clearSelection();

              document.getElementById("start-at").value = startLabel;
              const endEl = document.getElementById("end-at");
              if (endEl) endEl.value = endLabel;
              const dur = minutesBetweenHHMM_(startLabel, endLabel);
              setDuration_(dur);
              updateEndPreview_();
              rebuildEndPickerFromStart_();
              return;
            }

            // normal mode: click reservation to edit
            if (td.dataset.resId){
              hideCreateBar();
              clearSelection();
              openEdit(td.dataset.resId);
              return;
            }

            // normal create: 클릭으로 연속 선택(드래그 금지)
            // - 첫 클릭: 시작=끝(1칸)
            // - 같은 방에서 추가 클릭: 시작 기준으로 끝만 갱신(연속 구간 1개만)
            // - 다른 방 클릭: 선택 리셋
            // - 예약이 있는 칸을 포함하는 구간은 허용하지 않음(해당 클릭만 1칸 선택)
            (function clickSelect(){
              const slot = td.dataset.slot;
              const roomId = room.id;

              // 토글: 동일 1칸 재클릭 시 선택 해제
              if (state.pendingCreate &&
                  String(state.pendingCreate.roomId) === String(roomId) &&
                  state.dragStartSlot === slot &&
                  state.dragEndSlot === slot) {
                hideCreateBar();
                clearSelection();
                state.dragRoomId = null;
                state.dragStartSlot = null;
                state.dragEndSlot = null;
                return;
              }

              // 다른 방이면 시작점을 리셋
              if (!state.pendingCreate || String(state.pendingCreate.roomId) !== String(roomId)) {
                state.dragRoomId = roomId;
                state.dragStartSlot = slot;
                state.dragEndSlot = slot;
              } else {
                // 같은 방: 시작은 고정, 끝만 갱신
                state.dragRoomId = roomId;
                if (!state.dragStartSlot) state.dragStartSlot = slot;
                state.dragEndSlot = slot;
              }

              const si = state.slotIndex[state.dragStartSlot];
              const ei = state.slotIndex[state.dragEndSlot];
              const a = Math.min(si, ei);
              const b = Math.max(si, ei) + 1;

              // 구간 내 예약 포함 여부 체크(예약 포함 시: 클릭한 칸만 1칸 선택)
              let hasReserved = false;
              for (let k=a; k<b; k++){
                const key = roomId + "|" + state.data.slots[k];
                const cell = state.cellMap.get(key);
                if (cell && cell.dataset && cell.dataset.resId){
                  hasReserved = true;
                  break;
                }
              }
              if (hasReserved){
                state.dragStartSlot = slot;
                state.dragEndSlot = slot;
              }

              const si2 = state.slotIndex[state.dragStartSlot];
              const ei2 = state.slotIndex[state.dragEndSlot];
              const a2 = Math.min(si2, ei2);
              const b2 = Math.max(si2, ei2) + 1;

              markSelection(roomId, a2, b2);

              const startLabel = state.data.slots[a2];
              const endLabel = (b2 < state.data.slots.length) ? state.data.slots[b2] : state.data.close;
              showCreateBar(roomId, startLabel, endLabel);
            })();

            return;
});

          td.addEventListener("mouseover", () => {
            if (!state.dragging) return;
            // 시간 변경 모드에서는 드래그 무시
            if (state.timeChangeMode) return;
            if (state.dragRoomId !== room.id) return;

            state.dragEndSlot = td.dataset.slot;
            const si = state.slotIndex[state.dragStartSlot];
            const ei = state.slotIndex[state.dragEndSlot];
            const a = Math.min(si, ei);
            const b = Math.max(si, ei) + 1;
            markSelection(room.id, a, b);
          });

          td.addEventListener("mouseup", () => {
            if (!state.dragging) return;
            state.dragging = false;

            const si = state.slotIndex[state.dragStartSlot];
            const ei = state.slotIndex[state.dragEndSlot];
            const a = Math.min(si, ei);
            const b = Math.max(si, ei) + 1;

            // ✅ resize finish
            if (state.resizeMode) {
              const { resId, roomId, edge } = state.resizeMode;
              state.resizeMode = null;

              const rr = state.resRanges[resId];
              if (!rr) return;

              let newSi = rr.si;
              let newEi = rr.ei;

              if (edge === "start") {
                newSi = Math.min(a, rr.ei - 1);
                newEi = rr.ei;
              } else {
                newSi = rr.si;
                newEi = Math.max(b, rr.si + 1);
              }

              const startLabel = state.data.slots[newSi];
              const endLabel   = (newEi < state.data.slots.length) ? state.data.slots[newEi] : state.data.close;

              clearSelection();
              applyResizeToModal(resId, roomId, startLabel, endLabel);
              return;
            }

            const startLabel = state.data.slots[a];
            const endLabel = (b < state.data.slots.length) ? state.data.slots[b] : state.data.close;

            // 선택만 하고, '예약' 버튼을 눌러 모달을 띄웁니다.
            showCreateBar(room.id, startLabel, endLabel);
          });

          cells.push(td);
          tr.appendChild(td);
          state.cellMap.set(room.id + "|" + state.data.slots[i], td);
        }

        byRoom[room.id].blocks.forEach(b => markRange(cells, b, "blocked", "사용불가", null));
        byRoom[room.id].res.forEach(r => markRange(cells, r, "busy", r.title, r.id));

        tbody.appendChild(tr);
      });

    }


    function dtISOFromUI(dateStr, timeStr) {
      // 지원:
      // - dtISOFromUI("YYYY-MM-DD", "HH:MM")
      // - dtISOFromUI("YYYY-MM-DD HH:MM")
      // - dtISOFromUI("HH:MM")  <-- ✅ 이 케이스를 selectedDate로 보정

      if (dateStr === undefined || dateStr === null) {
        throw new Error("Missing date/time");
      }

      let dStr = String(dateStr).trim();
      let tStr = (timeStr === undefined || timeStr === null) ? "" : String(timeStr).trim();

      // ✅ case: time-only ("HH:MM")
      if (!tStr && /^\d{2}:\d{2}$/.test(dStr)) {
        const sd = getSelectedDate();
        tStr = dStr;
        dStr = sd;
      }

      // ✅ case: single string "YYYY-MM-DD HH:MM"
      if (!tStr) {
        const m1 = /^(\d{4}-\d{2}-\d{2})\s+(\d{2}:\d{2})$/.exec(dStr);
        if (m1) {
          dStr = m1[1];
          tStr = m1[2];
        }
      }

      const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(dStr);
      const t = /^(\d{2}):(\d{2})$/.exec(tStr);
      if (!m || !t) throw new Error(`Bad datetime format: ${String(dateStr).trim()}`);

      const y = Number(m[1]);
      const mo = Number(m[2]) - 1;
      const d = Number(m[3]);
      const hh = Number(t[1]);
      const mm = Number(t[2]);

      const local = new Date(y, mo, d, hh, mm, 0, 0);
      if (Number.isNaN(local.getTime())) throw new Error(`Invalid time value: ${dStr} ${tStr}`);

      // 로컬 오프셋 포함 ISO 문자열
      const off = -local.getTimezoneOffset(); // minutes
      const sign = off >= 0 ? "+" : "-";
      const offH = String(Math.floor(Math.abs(off) / 60)).padStart(2, "0");
      const offM = String(Math.abs(off) % 60).padStart(2, "0");

      const yyyy = String(y);
      const MM = String(mo + 1).padStart(2, "0");
      const DD = String(d).padStart(2, "0");
      const HH = String(hh).padStart(2, "0");
      const Min = String(mm).padStart(2, "0");

      return `${yyyy}-${MM}-${DD}T${HH}:${Min}:00${sign}${offH}:${offM}`;
    }






    function normalizeDateTimeInput(v){
      v = String(v || "").trim();
      // "HH:MM"만 오면 selectedDate 붙이기
      if (/^\d{2}:\d{2}$/.test(v)) return `${getSelectedDate()} ${v}`;
      return v;
    }


    // === Time helpers for modal (duration-based end time) ===
    function parseHHMM_(hhmmStr){
      const m = /^([0-2]\d):([0-5]\d)$/.exec(String(hhmmStr||"").trim());
      if (!m) return null;
      return {h:Number(m[1]), m:Number(m[2])};
    }

    function minutesBetweenHHMM_(startHH, endHH){
      const a = parseHHMM_(startHH);
      const b = parseHHMM_(endHH);
      if (!a || !b) return 60;
      let s = a.h*60 + a.m;
      let e = b.h*60 + b.m;
      // assume same day; if end earlier, clamp to 30
      let diff = e - s;
      if (diff <= 0) diff = 30;
      return diff;
    }

    function addMinutesToHHMM_(startHH, minutes){
      const a = parseHHMM_(startHH);
      if (!a) return "";
      let total = a.h*60 + a.m + Number(minutes||0);
      if (total < 0) total = 0;
      // clamp within day
      total = Math.min(total, 24*60);
      const hh = String(Math.floor(total/60)).padStart(2,"0");
      const mm = String(total%60).padStart(2,"0");
      return `${hh}:${mm}`;
    }

    function setDuration_(minutes){
      const sel = document.getElementById("duration");
      if (!sel) return;
      const v = String(Math.round(Number(minutes||60)));
      // if not present, add a custom option
      let opt = Array.from(sel.options).find(o => o.value === v);
      if (!opt){
        opt = document.createElement("option");
        opt.value = v;
        opt.textContent = `${v}분`;
        sel.appendChild(opt);
      }
      sel.value = v;
    }

    function updateEndPreview_(){
      const startEl = document.getElementById("start-at");
      const endEl = document.getElementById("end-at");
      const durEl = document.getElementById("duration");
      const prev = document.getElementById("end-preview");
      if (!startEl || !durEl) return;

      const s = String(startEl.value||"").trim();
      const d = Number(durEl.value||60);

      if (!s){
        if (prev) prev.textContent = "";
        if (endEl) endEl.value = "";
        return;
      }

      // 기본: duration으로 종료시간 계산
      const endHH = addMinutesToHHMM_(s, d);
      if (endEl && !endEl.value) endEl.value = endHH;

      // 표시 텍스트
      const shownEnd = endEl && endEl.value ? endEl.value : endHH;
      if (prev) prev.textContent = `종료 예정: ${shownEnd}`;
    }

    function syncEndFromDuration_(){
      const startEl = document.getElementById("start-at");
      const endEl = document.getElementById("end-at");
      const durEl = document.getElementById("duration");
      if (!startEl || !endEl || !durEl) return;
      const s = String(startEl.value||"").trim();
      if (!s) { endEl.value = ""; updateEndPreview_(); return; }
      const d = Number(durEl.value||60);
      endEl.value = addMinutesToHHMM_(s, d);
      updateEndPreview_();
    }

    function syncDurationFromEnd_(){
      const startEl = document.getElementById("start-at");
      const endEl = document.getElementById("end-at");
      const durEl = document.getElementById("duration");
      if (!startEl || !endEl || !durEl) return;
      const s = String(startEl.value||"").trim();
      const e = String(endEl.value||"").trim();
      if (!s || !e) { updateEndPreview_(); return; }
      const dur = minutesBetweenHHMM_(s, e);
      setDuration_(dur);
      updateEndPreview_();
    }



    async function saveReservation(){
      try {
        const resId = document.getElementById("res-id").value;
        const roomIdRaw = document.getElementById("room-id").value;
        const dateRaw = document.getElementById("modal-date")?.value || getSelectedDate();
        const startRaw = document.getElementById("start-at").value;
        const endRaw = document.getElementById("end-at")?.value || "";
        const durationMin = Number(document.getElementById("duration")?.value || 60);
// ✅ room_id는 숫자로
        const roomId = Number(roomIdRaw);

        // ✅ 현재 UI 값이 뭔지 먼저 확인
        console.log("[save] roomIdRaw=", roomIdRaw, "startRaw=", startRaw, "durationMin=", durationMin);

        const startAt = dtISOFromUI(dateRaw, String(startRaw||"").trim());
        // endAt: prefer explicit end field; fallback to duration
        let endHH = String(endRaw||"").trim();
        if (!endHH){ endHH = addMinutesToHHMM_(String(startRaw||"").trim(), durationMin); }
        const endAt = dtISOFromUI(dateRaw, endHH);

        // basic validation: end must be after start
        if (minutesBetweenHHMM_(String(startRaw||"").trim(), endHH) <= 0){
          alert("종료 시간이 시작 시간보다 늦어야 합니다.");
          return;
        }

        const title = document.getElementById("title").value;
        const note  = document.getElementById("note").value;

        console.log("[save] payload times:", startAt, endAt);

        if (!title.trim()){
          alert("단체명을 입력해 주세요.");
          return;
        }

        if (!resId){
          const pin = document.getElementById("pin").value;
          if (!/^\d{4}$/.test(pin)){
            alert("수정/취소 PIN(비번)은 숫자 4자리입니다.");
            return;
          }

          const repeatEnabled = !!document.getElementById("repeat-enabled")?.checked;
          const repeatDays = repeatEnabled
            ? Array.from(document.querySelectorAll(".repeat-dow:checked")).map(cb => Number(cb.value))
            : [];
          const repeatUntil = repeatEnabled
            ? String(document.getElementById("repeat-until")?.value || "").trim()
            : "";

          const payload = {room_id: roomId, start_at: startAt, end_at: endAt, title, note_internal: note, cancel_pin: pin};

          // repeat reservation (optional)
          if (repeatEnabled){
            if (repeatDays.length === 0){
              alert("반복 요일을 1개 이상 선택해 주세요.");
              return;
            }
            if (!/^\d{4}-\d{2}-\d{2}$/.test(repeatUntil)){
              alert("반복 종료일(언제까지)을 선택해 주세요.");
              return;
            }
            // server expects repeat_days (0=Sun..6=Sat) and repeat_until (YYYY-MM-DD)
            payload.repeat_days = repeatDays;
            payload.repeat_until = repeatUntil;
          }

          const resp = await fetch("/api/office/reservations", {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify(payload)
          });

          // ✅ Response body는 한 번만 읽습니다 (clone() 금지)
          const rawText = await resp.text();
          let out = null;
          try { out = rawText ? JSON.parse(rawText) : null; }
          catch(e) { out = {ok:false, error:"Invalid JSON from server", raw: rawText}; }

          console.log("[save] status=", resp.status, out ?? rawText);


          if (!resp.ok || !out || out.ok === false){
            const msg = (out && (out.error || out.detail || out.message)) ? (out.error || out.detail || out.message) : "저장 실패";
            const extra = (out && out.raw) ? String(out.raw).slice(0, 500) : "";
            alert(`${msg}\nHTTP ${resp.status}` + (extra ? `\n${extra}` : ""));
            return;
          }

          closeModal(); await load(); clearSelection(); return;

        } else {
          const pin = document.getElementById("pin").value;
          if (!/^\d{4}$/.test(pin)){
            alert("수정/취소 PIN은 숫자 4자리입니다.");
            return;
          }

          const newPin = document.getElementById("new-pin").value;
          if (newPin && !/^\d{4}$/.test(newPin)){
            alert("새 PIN은 숫자 4자리입니다.");
            return;
          }

          const payload = {room_id: roomId, start_at: startAt, end_at: endAt, title, note_internal: note, cancel_pin: pin};
          if (newPin) payload["new_cancel_pin"] = newPin;
          
          // 수정/취소 범위: 전체(반복 예약) 선택 시 series_id 추가
          const scope = (document.querySelector('input[name="cancel-scope"]:checked')?.value || "single");
          if (scope === "series"){
            const r = state.currentEdit || state.resById[resId];
            if (r && r.series_id) payload["series_id"] = r.series_id;
          }

          // include scope so server knows to apply series-wide update
          payload.scope = scope;

          try { console.log("[edit] payload=", JSON.stringify(payload)); } catch(e){ console.log("[edit] payload (obj)=", payload); }
          const resp = await fetch(`/api/office/reservations/${encodeURIComponent(resId)}`, {
            method: "PATCH",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify(payload)
          });

          const text = await resp.text();
          let out;
          try { out = JSON.parse(text); } catch(e) { out = {ok:false, error:"Invalid JSON from server", raw:text}; }

          console.log("[edit] status=", resp.status, out);

          if (!resp.ok || !out || out.ok === false){
            const msg = (out && (out.error || out.detail || out.message)) ? (out.error || out.detail || out.message) : "수정 실패";
            const extra = (out && out.raw) ? String(out.raw).slice(0, 500) : "";
            alert(`${msg}\nHTTP ${resp.status}` + (extra ? `\n${extra}` : ""));
            return;
          }

          // If series update was requested and server applied it, update any currently-loaded instances
          try {
            if (scope === "series" && out && out.ok && Array.isArray(out.updated)){
              console.log("[series-apply] updating", out.updated.length, "instances");
              out.updated.forEach(u => {
                const id = String(u.id);
                const existing = state.resById[id];
                console.log(`[series-apply] id=${id}, existing=${!!existing}, new_time=${u.start_at}~${u.end_at}`);
                if (existing){
                  existing.start_at = u.start_at;
                  existing.end_at = u.end_at;
                  existing.title = u.title;
                  existing.note_internal = u.note_internal || existing.note_internal;
                  state.resById[id] = existing;
                  const idx = state.data.reservations.findIndex(rr => String(rr.id) === id);
                  if (idx !== -1) state.data.reservations[idx] = existing;
                }
              });
              console.log("[series-apply] renderGrid calling...");
              renderGrid();
              console.log("[series-apply] done");
            }
          } catch(e){ console.warn("series client-side apply failed:", e); }

          closeModal(); await load(); clearSelection(); return;
        }

      } catch (err) {
        console.error(err);
        alert("생성/수정 중 오류:\n" + (err && err.stack ? err.stack : String(err)));
      }
    }


    async function cancelReservation(){
      const resId = document.getElementById("res-id").value;
      const pin = document.getElementById("pin").value;
      if (!/^\d{4}$/.test(pin)){
        alert("수정/취소 PIN은 숫자 4자리입니다.");
        return;
      }

      const scope = (document.querySelector('input[name="cancel-scope"]:checked')?.value || "single");
      const scopeLabel = (scope === "series") ? "전체 반복 예약" : "현재 예약";
      if (!confirm(`정말 취소할까요?\n(범위: ${scopeLabel})`)) return;

      const payload = {cancel_pin: pin, scope};

      // If backend supports grouping, pass any group id we have (optional)
      const r = state.currentEdit || state.resById[resId];
      if (scope === "series" && r){
        if (r.series_id) payload["series_id"] = r.series_id;
        if (r.group_id) payload["group_id"] = r.group_id;
        if (r.repeat_id) payload["repeat_id"] = r.repeat_id;
      }

      const resp = await fetch(`/api/office/reservations/${encodeURIComponent(resId)}/cancel`, {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify(payload)
      });
      const out = await resp.json();
      if (!out.ok){ alert(out.error || "취소 실패"); return; }
      closeModal(); await load(); clearSelection();
    }

    ensureDateInputDefault();


    load().catch(err => {
      console.error(err);
      alert("데이터를 불러오지 못했습니다.");
    });
  
// === UI helpers: selected date badge + Today button ===
function formatSelectedDateKo(dStr){
  if (!/^\d{4}-\d{2}-\d{2}$/.test(String(dStr||"").trim())) return String(dStr||"");
  const dt = new Date(dStr + "T00:00:00");
  const w = ["일","월","화","수","목","금","토"][dt.getDay()];
  return `${dStr} (${w})`;
}

function renderSelectedDateBadge(){
  const el = document.getElementById("selected-date-badge");
  if (!el) return;
  const d = (typeof getSelectedDate === "function") ? getSelectedDate() : (document.getElementById("date")?.value || "");
  el.innerHTML = `<span class="k">선택 날짜</span><span class="v">${formatSelectedDateKo(d)}</span>`;
}

function todayStr(){
  const now = new Date();
  const y = now.getFullYear();
  const m = String(now.getMonth()+1).padStart(2,"0");
  const d = String(now.getDate()).padStart(2,"0");
  return `${y}-${m}-${d}`;
}

async function goToday(){
  const el = document.getElementById("date") || document.querySelector('input[type="date"][name="date"]');
  if (el) el.value = todayStr();
  renderSelectedDateBadge();
  buildTime30Datalist();
  if (typeof load === "function") {
    try { await load(); } catch(e){ console.error(e); alert("데이터를 불러오지 못했습니다."); }
  }
}


// === 30-min time picker helper (datalist) ===
function buildTime30Datalist(){
  const dl = document.getElementById("time-30");
  if (!dl) return;
  dl.innerHTML = "";
  for (let h=0; h<24; h++){
    for (let m=0; m<60; m+=30){
      const hh = String(h).padStart(2,"0");
      const mm = String(m).padStart(2,"0");
      const opt = document.createElement("option");
      opt.value = `${hh}:${mm}`;
      dl.appendChild(opt);
    }
  }
}
document.addEventListener("DOMContentLoaded", () => {
  renderSelectedDateBadge();
  buildTime30Datalist();

  // === Create bar buttons (Reserve / Cancel) ===
  // The create bar appears after selecting a contiguous time range.
  // Open the create modal only when pressing "예약".
  const btnCreateOpen = document.getElementById('btn-create-open');
  if (btnCreateOpen) {
    btnCreateOpen.addEventListener('click', (e) => {
      e.preventDefault();
      console.log("[btn-create-open] clicked");
      openCreateFromBar();
    });
  } else {
    console.warn("[init] btn-create-open not found");
  }
  const btnCreateCancel = document.getElementById('btn-create-cancel');
  if (btnCreateCancel) {
    btnCreateCancel.addEventListener('click', (e) => {
      e.preventDefault();
      console.log("[btn-create-cancel] clicked");
      cancelCreateSelection();
    });
  } else {
    console.warn("[init] btn-create-cancel not found");
  }

  const dateEl = document.getElementById("date") || document.querySelector('input[type="date"][name="date"]');
  if (dateEl){
    dateEl.addEventListener("change", () => {
      renderSelectedDateBadge();
  buildTime30Datalist();
      if (typeof load === "function") load().catch(e => { console.error(e); });
    });
  }

  const btn = document.getElementById("btn-today");
  if (btn) btn.addEventListener("click", (e) => { e.preventDefault(); goToday(); });

  // ✅ Initial load: fetch grid data
  if (typeof load === "function") {
    load().catch(e => { 
      console.error("[init] load() failed:", e);
      alert("그리드 로드 실패: " + e.message);
    });
  } else {
    console.error("[init] load function not available");
  }

  // === Repeat reservation UI toggle ===
  const repEn = document.getElementById("repeat-enabled");
  const repOpts = document.getElementById("repeat-options");
  const untilEl2 = document.getElementById("repeat-until");

  function _formatDateYYYYMMDD_(d){
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const da = String(d.getDate()).padStart(2,'0');
    return `${y}-${m}-${da}`;
  }

  function syncRepeatUI_(){
    const on = !!repEn?.checked;
    if (repOpts) repOpts.style.display = on ? "flex" : "none";

    if (!on){
      document.querySelectorAll(".repeat-dow").forEach(cb => cb.checked = false);
      if (untilEl2) untilEl2.value = "";
      return;
    }

    // If enabling and until is empty, default to +4 weeks from selected date
    if (untilEl2 && !untilEl2.value){
      const base = (document.getElementById("date")?.value || "").trim();
      if (/^\d{4}-\d{2}-\d{2}$/.test(base)){
        const d = new Date(base + "T00:00:00");
        d.setDate(d.getDate() + 28);
        untilEl2.value = _formatDateYYYYMMDD_(d);
      }
    }

    // If enabling and no weekday is selected yet, auto-select the weekday of the selected date
    const anyDowChecked = Array.from(document.querySelectorAll(".repeat-dow")).some(cb => cb.checked);
    if (!anyDowChecked){
      const base2 = (document.getElementById("date")?.value || "").trim();
      let d2 = null;
      if (/^\d{4}-\d{2}-\d{2}$/.test(base2)){
        d2 = new Date(base2 + "T00:00:00");
      } else {
        d2 = new Date();
      }
      const dow = d2.getDay(); // 0=Sun ... 6=Sat
      const cb = document.querySelector(`.repeat-dow[value="${dow}"]`) || document.getElementById(`dow-${dow}`);
      if (cb) cb.checked = true;
    }
  }

  if (repEn) repEn.addEventListener("change", syncRepeatUI_);
  syncRepeatUI_();

  // === Modal date/start/end sync + native time picker ===
  const modalDateEl = document.getElementById("modal-date");
  const startEl = document.getElementById("start-at");
  const endEl = document.getElementById("end-at");
  const durEl = document.getElementById("duration");
  if (startEl){
    startEl.addEventListener("click", () => {
      // some browsers support showPicker()
      try { if (typeof startEl.showPicker === "function") startEl.showPicker(); } catch(e){}
    });
    startEl.addEventListener("change", () => {
      // start 변경 시 종료 시간 picker 옵션 재구성 + duration 기준으로 end 재계산
      rebuildEndPickerFromStart_();
      syncEndFromDuration_();
    });
  }
  if (durEl){
    durEl.addEventListener("change", () => {
      // duration 변경 시 end 재계산
      syncEndFromDuration_();
    });
  }
  if (endEl){
    endEl.addEventListener("click", () => {
      try { if (typeof endEl.showPicker === "function") endEl.showPicker(); } catch(e){}
    });
    endEl.addEventListener("change", () => {
      // end 변경 시 duration을 맞춰줌
      syncDurationFromEnd_();
    });
  }
  if (modalDateEl){
    // 날짜 변경 시에는 시간 값은 유지하고, 표시만 업데이트
    modalDateEl.addEventListener("change", () => updateEndPreview_());
  }

});

</script>
</body>
</html>

